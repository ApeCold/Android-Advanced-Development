01.RxJava概念与观察者设计模式。
    1.起点 和 终点，一旦满足 起点 和 终点 这样的需求，都可以使用RxJava来实现。
    2.标准中的观察者设计模式，一个被观察者 ---- 多个观察者 多次注册。
    3.RxJava是改装的观察者设计模式，一个订阅(注册) 一个观察者。

////////////////////////////////////////////////////////////////////////////////////////////////////
02.RxJava上游和下游。
    1.上游 Observable 被观察者， 下游 Observer 观察者。
    2.ObservableEmitter<Integer> emitter 发射器 发射事件。
    3.拆分来写的，链式调用。
    4.RxJava流程1，大致流程，同学们去看代码。
    5.RxJava流程2，3个结论。
    6.RxJava切断下游，让下游不再接收上游发射的事件。

////////////////////////////////////////////////////////////////////////////////////////////////////
03.RxJava创建型操作符 -- 专门创建 被观察者/上游/Observable。
观察者：下游，接收事件  完整版本Observer  简化版Consumer
create：使用者自己发射事件
just 内部自己发射的，单一对象
fromArray 内部自己发射的，数集对象
empty：内部自己发射的 ，下游默认是Object，无法发出有值事件，只会发射 onComplete
range：内部自己发射的，start 1 累加   count 5    最后结果：1 2 3 4 5

////////////////////////////////////////////////////////////////////////////////////////////////////
04.RxJava变换型操作符。
上游  ------->    变换操作(往右边流向的时候，进行变换)  ---------->  下游
1.map       把上一层Int  Int变换String                                           观察者String类型。
2.flatMap   把上一层Int  Int变换ObservableSource<String>{还可以再次发射多次事件}   观察者String类型。 不排序的
3.concatMap 把上一层Int  Int变换ObservableSource<Bitmap>{还可以再次发射多次事件}   观察者Bitmap类型。 排序的
4.groupBy   把上一层Int  Int变换String(高端配置电脑)     观察者GroupedObservable类型 {key="高端", 细节再包裹一层}
5.buffer    100个事件 Integer     .buffer(20)    观察者List<Integer>==五个集合

////////////////////////////////////////////////////////////////////////////////////////////////////
05.RxJava过滤型操作符。
上游  ------->    过滤操作(往右边流向的时候，进行过滤)  ---------->  下游
1.filter 如果是false全部都发射给下游，如果是true，全部都不发射给下游。
2.take ：只有再定时器运行基础上 加入take过滤操作符，才有take过滤操作符的价值。
3.distinct过滤重复事件。
4.elementAl 指定发射事件内容，如果无法指定，有默认的事件。


////////////////////////////////////////////////////////////////////////////////////////////////////
06.RxJava条件型操作符。
上游  ------->    条件操作(往右边流向的时候，条件判断)  ---------->  下游
操作符：RxJava说的很神奇，API的调用， RxJava改变开发者的思维
RxJava == Java编程
语法 == 操作符API
所有的操作符都学会了，才能真正的证明把RxJava的使用学会了 == Java所有的语法学会，Java入门
RxJava作为: Android之神 2010 开源过Android开源的框架库， RxJava巅峰之作

All: 如同 if 那样的功能 ：全部为true，才是true，只要有一个为false，就是false.
contains 是否包含
any 全部为 false，才是false， 只要有一个为true，就是true
如果使用了条件操作符，下一层，接收的类型 就是条件类型(Boolean)

////////////////////////////////////////////////////////////////////////////////////////////////////
07.RxJava合并型操作符。
两个或者多个 被观察者 合并。
1.startWait，concatWith ：先创建被观察者，然后再组合其他的被观察者，然后再订阅
2.concat/merge/zip：直接合并多个被观察者，然后订阅
细节：
a:startWait 先执行 startWait括号里面的被观察者
b:concatWait 后执行 concatWait括号里面的被观察者
c:concat 是按照顺序依次执行 最多四个被观察者进行合并
d:merge 并列执行的，（演示并列的执行，所以学了intervalRange） 最多四个被观察者进行合并
e:zip 需要对应关系 需要对应，如果不对应，会被忽略的， 最多9个被观察者 进行合并

////////////////////////////////////////////////////////////////////////////////////////////////////
08.RxJava异常处理操作符。
1.RxJava中是不标准的throw new IllegalAccessError("我要报错了");
2. RxJava标准的e.onError(XXX);
3.onErrorReturn最先拦截到e.onError并且可以给下游返回一个 标识400,   throw new  XXX 拦截不到，整个程序奔溃
4.onErrorResumeNext最先拦截到e.onError并且可以给下游返回一个 被观察者（还可以再次发送）,   throw new  XXX 拦截不到，整个程序奔溃
5.onExceptionResumeNext 能在发生异常的时候，扭转乾坤，能够处理 throw new  XXX，可以真正的让App不奔溃
6.retry return false; 代表不去重试  return true; 不停的重试，  演示二 重试次数，  演示三 打印重试了多少次，计数

////////////////////////////////////////////////////////////////////////////////////////////////////
09.RxJava线程切换。
1.异步线程区域
        Schedulers.io() ：代表io流操作，网络操作，文件流，耗时操作
        Schedulers.newThread()    ： 比较常规的，普普通通
        Schedulers.computation()  ： 代表CPU 大量计算 所需要的线程
2.AndroidSchedulers.mainThread()  ： 专门为Android main线程量身定做的
3.给上游分配多次，只会在第一次切换，后面的不切换了（忽略）
4.给下游分配多次，每次都会去切换
5.如果不配置异步线程，上游发一次，下游接收一次，上游发一次，下游接收一次，上游发一次，下游接收一次
6.配置好异步线程，就是异步的表现
7.传统下载图片的写法，容易四分五裂
8.RxJava下载图片，基于事件流编程，一条链子，起点和终点

////////////////////////////////////////////////////////////////////////////////////////////////////
10.RxJava背压模式。
背压模式的由来：
 RxJava1.X的时候，还没有背压模式， 我们的上游不停的发射，我们的下游处理不过来，就会照成内存泄漏
 RxJava2.X之后，增加背压模式，Observable  Flowable（解决背压）

Observable --- > Flowable（解决背压）

什么时候用Observable<--->Observer， 什么使用Flowable<--->Subscriber ？
答：发射的事件，大量的事件(1000个)，并且考虑到下游处理不过来，就需要使用Flowable

1.// ERROR  放入缓存池，如果池子满了  水缸  max 128
 BackpressureStrategy.ERROR // todo 上游不停的发射大量事件，下游阻塞了 处理不过来，放入缓存池，如果池子满了，就会抛出异常
2.BackpressureStrategy.BUFFER // todo  上游不停的发射大量事件，下游阻塞了 处理不过来，放入缓存池，”等待“下游来接收事件处理
3.同步的，没有执行Subscription s.request(), 当上游发射1，下游无法处理（没有执行s.request()），会抛出异常
4.异步的，上游不停的发射，可以在r02方法中，s.request(10)  可以取出来给 下游接收事件处理的
5.一旦下游处理了一次上游的事件，缓存池 - 1
6.Observable 它的升级版 Flowable：功能强大，还有背压模式。


////////////////////////////////////////////////////////////////////////////////////////////////////
11.Flowable  --- Observable
如果我们会使用Observable， 那么一定会使用Flowable
Flowable的设计，是按照Observable 依葫芦画瓢来设计Flowable，所以使用才一摸一样，只不过类名不同而已， Flowable还增加了背压模式
1.Observable<--->Observer， Flowable<--->Subscriber  对应关系 ？
2.Observable的设计和  Flowable一致的，在Observable的基础上 增加了一套Flowable的代码，而且增加的时候 依葫芦画瓢的，Flowable增加了背压模式
3.Observable--Observer下游 -- onSubscribe(Disposable d)切断下游（水管）
4.Flowable---Subscriber下游 -- onSubscribe(Subscription s) 取出（s.request(5)）事件 给下游接收使用

////////////////////////////////////////////////////////////////////////////////////////////////////
12.RxJava配合Retrofit。
RxJava + Retrofit （请求网络OkHttp  ---- Retorfit  --- Observable）

1.OkHttp 请求网络 （Retorfit）
2.Retorfit 返回一个结果 （Retorfit） --- Observable
3.最终的结果 是RxJava中的 被观察者 上游 Observable
4.一行代码写完需求流程： 从上往下
   1.请求服务器，执行注册操作（耗时）切换异步线程
   2.更新注册后的所有 注册相关UI - main  切换主线程
   3.请求服务器，执行登录操作（耗时）切换异步线程
   4.更新登录后的所有 登录相关UI - main  切换主线程

5.看RxJava另外一种的执行流程
  初始点 开始点 订阅
  1.onSubscribe
  2.registerAction(new RegisterRequest())
  3..doOnNext 更新注册后的 所有UI
  4.flatMap执行登录的耗时操作
  5.订阅的观察者 下游 onNext 方法，更新所有登录后的UI
  6.progressDialog.dismiss()

////////////////////////////////////////////////////////////////////////////////////////////////////
13.泛型 Java
由于RxJava大量的使用到了泛型，所有学习
如果我们不指定泛型类型，默认就是Object，Object的扩展集
1.? super F   下限：F or F 所有父类 都可以，所以属于把下面的类型限限制了，下面的类型不能低于F，不能是F的子类，否则编译不通过。
2.? extends F 上限：F or F 所有子类 都可以，所有属于把上面的类型给限制了，上面的类型不能高于F，不能是F的父类，否则编译不通过。
  一句话记住（? super F: F 或者 F的所有父类 都可以，   ? extends F: F 或者 F的所有子类都可以）
3.可写模式<？super F> 可写，不完全可读
4.可读模式<? extends F> 可读，不可写


/////////////////////////////////////////////// RxJava手写阶段 /////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////
14.RxJava手写create操作符。


////////////////////////////////////////////////////////////////////////////////////////////////////
15.RxJava手写create增加读写模式。

RxJava执行的流程：
 订阅
   subscribe方法  ---》 上游发射器 observableEmitter.xxx ---> Observer 三个方法中 接收

 什么时候能够区分是 读写模式， 什么时候可以区分是 上限和下限的方式 ？
 答：在方法参数中，show2(Test<? super Student> test) 一定是 上限和下限
     在真正使用到泛型中，就是读写模式


////////////////////////////////////////////////////////////////////////////////////////////////////
16.RxJava手写just操作符。
create操作符是使用者自己去发射事件的，just操作符是内部去发射的
    订阅
        subscribe方法  --- just（内部会去发射事件，根据我们传递的参数来发射事件的） observer.onNext(); --》 下游就接收到了事件
1类：使用者自己发射 ---》 create操作符
2类：内部自己发射 --》jsut / fromArray ...


////////////////////////////////////////////////////////////////////////////////////////////////////
17.RxJava手写map操作符 （变换） RxJava的核心
1.变换操作符，只管上一层----> 给的类型，把上一层类型变换的新的类型 ----> 下一层
2.Map控制上一层的能力（要把自己交付给上一层）， Map控制下一层的能力 observer 去做事情


////////////////////////////////////////////////////////////////////////////////////////////////////
18.RxJava手写之create和map等流程。
看RxJava的流程，正确的看源码方式（RxJava独有的）
  （从右往左（反方向）先倒着走，然后（事件流向 从左往右）顺这走

    [从右往左走]
   订阅 ----> observer.onSubscribe(); --》source.subscribe(observer); ---> ObservableMap.subscribe（会包裹一层，给上一层） ---> 最顶层的上游 （使用者自己去发射的）

     [从左往右走]
   ( 使用者自己去发射的 .onNext())  -----> MapObserver.onNext() ---> 最右边的观察者.onNext();


////////////////////////////////////////////////////////////////////////////////////////////////////
19.RxJava无死角回顾。
 1.RxJava的概念 和 标准观察者设计模式（多个观察者，注册多次）  -- RxJava中的观察者设计模式(不标准 变异)（一个观察者，订阅一次）。
 2.RxJava上游和下游，
 3.RxJava创建型操作符。 创建（被观察者） create just fromArray ...
 4.RxJava变换型操作符。 上一层的事件类型 变换 下一层需要的事件类型
 5.RxJava过滤型操作符。 上一层的事件，过滤筛选  给下一层
 6.RxJava条件型操作符。 把上一层的事件 ，是否满足条件  给下一层 Boolean
 7.RxJava合并型操作符。 把多个被观察者 合并成一个被观察者  --- 》 发射事件
 8.RxJava异常型操作符。 上一层发射事件 异常的处理  异常操作符 -- try   ----》 下一层。
 9.RxJava线程的切换。 默认情况下main线程， 异步线程io， 主线程AndroidSchedulers.mainThread()
                     给上游分配多次，只会在第一次切换，后面的不切换了 （只在第一次有效）
                     给下游分配多次，每次都会去切换 （每次都会有效）
 10.背压  上游大量的发射事件，下游处理（阻塞）不过来，就会考虑到我们背压模式(ERROR, BUFFER)
 11.RxJava Flowable --- Observable
 12.RxJava配合Retrofit+OkHttp
 13.RxJava泛型 上限和下限，读写模式
 14.RxJava手写create操作符, 就是一个接口回调。
 15.RxJava手写create操作符的读写模式。(在方法参数中：一定是上限和下限,   真正的使用到了泛型操作：读写模式)
 16.RxJava手写jsut操作符，就是一个接口回调，在just方法里面调用的。
 17.RxJava手写map操作符。变换操作符
 18.RxJava手写map+create+observer操作符流程讲解，从订阅到上游，然后再从上游到下游
 19.RxJava回顾

核心内容：
变换操作符，异常操作符，线程切换，背压模式的Buffer/Error，泛型的读写模式，手写map操作符/map+create+observer操作符流程

难点内容：
map+create+observer操作符流程








无论是：插件化课程，还是RxJava课程，等等，都是老师主动去增加课程内容（例如:原本只需录制四个视频），主要是想同学们多学一点