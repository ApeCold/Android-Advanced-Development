1.Glide手写实现之资源封装
资源封装
Key   -- 对Value的唯一性进行描述
Value -- Bitmap的封装(+1, -1, 释放)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

2.Glide手写实现之活动缓存
2.1回收机制：GC扫描的时候回收,移除容器（GC被动移除）（弱引用）
2.2容器管理方式：资源的封装 Key  ----- （弱引用<Value>)
2.3手动移除的区分
2.4关闭线程
2.5Value监听加入

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

3.Glide手写实现之内存缓存（LRU算法）
LRU算法：最近没有使用的元素，会自动被移除掉
职责：
活动缓存：给正在使用的资源存储的，弱引用
内存缓存：为第二次缓存服务，LRU算法
LRU算法: ---> 最近没有使用的元素，会自动被移除掉
把最近没有使用到的元素给移除
LruCache v4：
利用LinkedHashMap<K, V>，
LinkedHashMap: true==拥有访问排序的功能 (最少使用元素算法-LRU算法)

put：
    1.如果是重复的key，会被移除掉一个
    key=15151511551
    previous = key=15151511551
    entryRemoved
    2.trimToSize 移除哪些最近没有使用的元素 ---》 entryRemoved

同学们注意：注意注意：这节课中，老师有一个地方说错了，(LinkedHashMap: true==是拥有访问排序的功能)  并不是（插入排序），是访问排序

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

4.Glide手写实现之磁盘缓存
保存时长比较长：保存在本地磁盘 文件的形式存储 （不再是保存在运行内存中，而是磁盘中）
LRU算法: ---> 最近没有使用的元素，会自动被移除掉
LruCahce -- Android中提供了 V4
DiskLruCache --- Android中没有提供了 --> DiskLruCache
DiskLruCache：回收方式：LRU算法， 访问排序
DiskLruCache: 面向磁盘文件保存
sp == Editor edit
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


5.Glide手写实现之生命周期
组拼接之前的所有内容 --> Glide
生命周期的管理：Application不能去管理，FragmentActivity可以去管理，Activity也可以去管理
管理的方式：在Activity组件上 附件Fragment，通过Fragment监听组件的生命周期

Activity ---> app Fragment
AppCompatActivity --> V4包 Fragment
为什么发送一次Handler？
我们的Android基于Handler消息的，LAUNCH_ACTIVITY，为了让我们的fragment，不要再排队中，为了下次可以取出来
移除Handler


6.Glide手写实现之加载图片
组拼接之前的所有内容（缓存） --> Glide